import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { 
  ChevronDown, ChevronUp, Plus, Lightbulb, 
  Sparkles, ThumbsUp, Send, X, Loader2,
  Circle, CheckCircle2, PlayCircle, TestTube2,
  Edit2, MessageCircle, ArrowLeft, Clock, ArrowUp,
  Vote, Users
} from 'lucide-react';
import { toast } from 'sonner';
import { RoadmapSettings, getTheme } from '@/lib/roadmapThemes';

// Animated floating orb component for background glow effects
const FloatingOrb = ({ 
  color, 
  size, 
  position, 
  delay = 0 
}: { 
  color: string; 
  size: number; 
  position: { top?: string; bottom?: string; left?: string; right?: string }; 
  delay?: number;
}) => {
  const [offset, setOffset] = useState({ x: 0, y: 0, rotation: 0 });

  useEffect(() => {
    let animationId: number;
    let startTime = Date.now() + delay * 1000;
    
    const animate = () => {
      const elapsed = (Date.now() - startTime) / 1000;
      const x = Math.sin(elapsed * 0.3) * 40;
      const y = Math.cos(elapsed * 0.2) * 40;
      const rotation = elapsed * 10;
      setOffset({ x, y, rotation });
      animationId = requestAnimationFrame(animate);
    };
    
    animate();
    return () => cancelAnimationFrame(animationId);
  }, [delay]);

  return (
    <div
      className="absolute rounded-full pointer-events-none"
      style={{
        ...position,
        width: size,
        height: size,
        background: `linear-gradient(135deg, ${color}60, ${color}30)`,
        filter: 'blur(80px)',
        opacity: 0.6,
        transform: `translateX(${offset.x}px) translateY(${offset.y}px) rotate(${offset.rotation}deg) translateZ(0px)`,
        transition: 'transform 0.1s linear'
      }}
    />
  );
};

interface RoadmapVersion {
  id: string;
  creator_id: string;
  version_name: string;
  description?: string;
  status: string;
  sort_order: number;
  is_expanded: boolean;
  status_changed_at?: string;
  created_at?: string;
  items?: RoadmapItem[];
}

interface RoadmapItem {
  id: string;
  version_id: string;
  title: string;
  description?: string;
  status: string;
  sort_order: number;
  status_changed_at?: string;
  created_at?: string;
  vote_count?: number;
  user_has_voted?: boolean;
  voting_enabled?: boolean; // Per-item voting toggle
}

interface SuggestionAuthor {
  id: string;
  display_name?: string;
  avatar_url?: string;
}

interface RoadmapSuggestion {
  id: string;
  creator_id: string;
  user_id: string;
  title: string;
  description?: string;
  upvotes: number;
  user_upvoted?: boolean;
  forum_status?: 'open' | 'planned' | 'in_progress' | 'completed' | 'declined';
  status_changed_at?: string;
  created_at?: string;
  reply_count?: number;
  author?: SuggestionAuthor;
}

interface SuggestionReply {
  id: string;
  suggestion_id: string;
  user_id: string;
  content: string;
  created_at: string;
  updated_at?: string;
  author?: SuggestionAuthor;
  is_creator?: boolean;
}

interface GlobalBackgroundSettings {
  enabled?: boolean;
  type?: 'solid' | 'gradient' | 'image';
  color?: string;
  gradientStart?: string;
  gradientEnd?: string;
  image?: string;
  overlay?: number;
}

interface RoadmapPageProps {
  creatorId: string;
  isOwner: boolean;
  settings: RoadmapSettings;
  storeName?: string;
  storeLogo?: string;
  productId?: string;
  onBack?: () => void;
  votingEnabled?: boolean;
  sortByVotes?: boolean;
  storeSlug?: string; // For linking to community page
  globalBackground?: GlobalBackgroundSettings;
}

const STATUS_ICONS: Record<string, React.ElementType> = {
  backlog: Circle,
  in_progress: PlayCircle,
  qa: TestTube2,
  completed: CheckCircle2,
};

export const RoadmapPage = ({ creatorId, isOwner, settings, storeName, storeLogo, productId, onBack, votingEnabled = false, sortByVotes = false, storeSlug, globalBackground }: RoadmapPageProps) => {
  const { user } = useAuth();
  const navigate = useNavigate();
  const theme = getTheme(settings);
  
  // Helper function to convert hex to rgba with proper opacity
  const hexToRgba = (hex: string, opacity: number) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
  };

  // Helper function to get card background with proper opacity
  const getCardBackground = () => {
    const baseColor = settings.useCustomColors && settings.customCardBackground 
      ? settings.customCardBackground 
      : theme.cardBackground;
    
    // If the color already has alpha (rgba), extract RGB and apply cardOpacity
    if (baseColor.includes('rgba')) {
      const rgbaMatch = baseColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)/);
      if (rgbaMatch) {
        const [, r, g, b] = rgbaMatch;
        const opacity = (settings.cardOpacity || 80) / 100;
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
      }
    }
    
    // If it's a hex color, convert to rgba with cardOpacity
    if (baseColor.startsWith('#')) {
      const opacity = (settings.cardOpacity || 80) / 100;
      return hexToRgba(baseColor, opacity);
    }
    
    return baseColor;
  };

  // Dynamic status colors based on theme with proper opacity handling
  const STATUS_COLORS: Record<string, { bg: string; border: string; text: string }> = {
    backlog: { 
      bg: hexToRgba(theme.statusColors.backlog, 0.35),
      border: theme.statusColors.backlog, 
      text: theme.statusColors.backlog 
    },
    in_progress: { 
      bg: hexToRgba(theme.statusColors.in_progress, 0.35),
      border: theme.statusColors.in_progress, 
      text: theme.statusColors.in_progress 
    },
    qa: { 
      bg: hexToRgba(theme.statusColors.qa, 0.35),
      border: theme.statusColors.qa, 
      text: theme.statusColors.qa 
    },
    completed: { 
      bg: hexToRgba(theme.statusColors.completed, 0.35),
      border: theme.statusColors.completed, 
      text: theme.statusColors.completed 
    },
  };
  const [versions, setVersions] = useState<RoadmapVersion[]>([]);
  const [suggestions, setSuggestions] = useState<RoadmapSuggestion[]>([]);
  const [loading, setLoading] = useState(true);
  const [expanded, setExpanded] = useState<Record<string, boolean>>({});
  const [showModal, setShowModal] = useState(false);
  const [suggestionTitle, setSuggestionTitle] = useState('');
  const [suggestionDesc, setSuggestionDesc] = useState('');
  const [submitting, setSubmitting] = useState(false);
  const [newVersion, setNewVersion] = useState('');
  const [newItem, setNewItem] = useState('');
  const [newItemDesc, setNewItemDesc] = useState('');
  const [addingTo, setAddingTo] = useState<string | null>(null);
  const [productName, setProductName] = useState<string>('');
  const [itemVotingEnabled, setItemVotingEnabled] = useState(votingEnabled);
  const [itemSortByVotes, setItemSortByVotes] = useState(sortByVotes);
  
  // Editing state
  const [editingVersionId, setEditingVersionId] = useState<string | null>(null);
  const [editingVersionDesc, setEditingVersionDesc] = useState('');
  const [editingTaskId, setEditingTaskId] = useState<string | null>(null);
  const [editingTaskTitle, setEditingTaskTitle] = useState('');
  const [editingTaskDesc, setEditingTaskDesc] = useState('');
  
  // Forum state
  const [selectedSuggestion, setSelectedSuggestion] = useState<RoadmapSuggestion | null>(null);
  const [suggestionReplies, setSuggestionReplies] = useState<SuggestionReply[]>([]);
  const [replyContent, setReplyContent] = useState('');
  const [loadingReplies, setLoadingReplies] = useState(false);
  const [sortBy, setSortBy] = useState<'upvotes' | 'newest' | 'discussed'>('upvotes');

  // Helper function to format relative time
  const formatRelativeTime = (dateString?: string) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    return date.toLocaleDateString();
  };

  // Helper function to format completion date
  const formatCompletionDate = (dateString?: string) => {
    if (!dateString) return '';
    return new Date(dateString).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric', 
      year: 'numeric' 
    });
  };

  // Spacing map
  const spacingMap: Record<string, string> = {
    compact: 'space-y-3',
    normal: 'space-y-4',
    relaxed: 'space-y-6'
  };
  const sectionSpacing = spacingMap[settings.sectionSpacing || 'normal'] || 'space-y-4';

  useEffect(() => { fetchData(); }, [creatorId, productId]);

  const fetchData = async () => {
    try {
      // Fetch product name and voting settings if productId is provided
      if (productId) {
        const { data: product } = await (supabase as any)
          .from('products')
          .select('title, voting_enabled, sort_by_votes')
          .eq('id', productId)
          .single();
        if (product) {
          setProductName(product.title);
          setItemVotingEnabled(product.voting_enabled || false);
          setItemSortByVotes(product.sort_by_votes || false);
        }
      }

      // Build query for versions - filter by product_id if provided
      let versionsQuery = (supabase as any).from('roadmap_versions').select('*').eq('creator_id', creatorId);
      if (productId) {
        versionsQuery = versionsQuery.eq('product_id', productId);
      }
      const { data: v } = await versionsQuery.order('sort_order');
      
      // Build query for items
      let itemsQuery = (supabase as any).from('roadmap_items').select('*').eq('creator_id', creatorId);
      if (productId) {
        itemsQuery = itemsQuery.eq('product_id', productId);
      }
      const { data: items } = await itemsQuery.order('sort_order');
      
      // Fetch vote counts for all items
      let enrichedItems = items || [];
      if (enrichedItems.length > 0) {
        const itemIds = enrichedItems.map((i: any) => i.id);
        
        // Get vote counts
        const { data: voteCounts } = await (supabase as any)
          .from('roadmap_item_votes')
          .select('item_id')
          .in('item_id', itemIds);
        
        const voteCountMap = new Map<string, number>();
        (voteCounts || []).forEach((v: any) => {
          voteCountMap.set(v.item_id, (voteCountMap.get(v.item_id) || 0) + 1);
        });
        
        // Get user's votes if logged in
        let userVotedItems = new Set<string>();
        if (user) {
          const { data: userVotes } = await (supabase as any)
            .from('roadmap_item_votes')
            .select('item_id')
            .eq('user_id', user.id)
            .in('item_id', itemIds);
          userVotedItems = new Set((userVotes || []).map((v: any) => v.item_id));
        }
        
        enrichedItems = enrichedItems.map((item: any) => ({
          ...item,
          vote_count: voteCountMap.get(item.id) || 0,
          user_has_voted: userVotedItems.has(item.id)
        }));
      }
      
      const combined = (v || []).map((ver: any) => {
        let versionItems = enrichedItems.filter((i: any) => i.version_id === ver.id);
        // Sort by votes if enabled
        if (itemSortByVotes) {
          versionItems.sort((a: any, b: any) => (b.vote_count || 0) - (a.vote_count || 0));
        }
        return { ...ver, items: versionItems };
      });
      setVersions(combined);
      const exp: Record<string, boolean> = {};
      combined.forEach((ver: any) => { exp[ver.id] = settings.defaultExpanded ?? true; });
      setExpanded(exp);

      if (settings.showSuggestions) {
        const { data: sug } = await (supabase as any).from('roadmap_suggestions').select('*').eq('creator_id', creatorId).order('upvotes', { ascending: false });
        if (sug) {
          // Get reply counts for each suggestion
          const suggestionIds = sug.map((s: any) => s.id);
          const { data: replyCounts } = await (supabase as any)
            .from('roadmap_suggestion_replies')
            .select('suggestion_id')
            .in('suggestion_id', suggestionIds);
          
          const countMap = new Map<string, number>();
          (replyCounts || []).forEach((r: any) => {
            countMap.set(r.suggestion_id, (countMap.get(r.suggestion_id) || 0) + 1);
          });

          // Get author profiles
          const userIds = [...new Set(sug.map((s: any) => s.user_id))];
          const { data: profiles } = await (supabase as any)
            .from('profiles')
            .select('user_id, display_name, avatar_url')
            .in('user_id', userIds);
          
          const profileMap = new Map((profiles || []).map((p: any) => [p.user_id, p]));

          let enrichedSuggestions = sug.map((s: any) => ({
            ...s,
            reply_count: countMap.get(s.id) || 0,
            author: profileMap.get(s.user_id) || { display_name: 'Anonymous' }
          }));

          // Apply sorting
          if (sortBy === 'newest') {
            enrichedSuggestions.sort((a: any, b: any) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());
          } else if (sortBy === 'discussed') {
            enrichedSuggestions.sort((a: any, b: any) => (b.reply_count || 0) - (a.reply_count || 0));
          }
          // Default is already sorted by upvotes from the query

          if (user) {
            const { data: ups } = await (supabase as any).from('roadmap_suggestion_upvotes').select('suggestion_id').eq('user_id', user.id);
            const upIds = new Set((ups || []).map((u: any) => u.suggestion_id));
            setSuggestions(enrichedSuggestions.map((s: any) => ({ ...s, user_upvoted: upIds.has(s.id) })));
          } else {
            setSuggestions(enrichedSuggestions);
          }
        } else {
          setSuggestions([]);
        }
      }
    } catch (e) { console.error(e); }
    setLoading(false);
  };

  const addVersion = async () => {
    if (!newVersion.trim()) return;
    // Insert at sort_order 0 and shift others down
    const insertData: any = { creator_id: creatorId, version_name: newVersion.trim(), sort_order: 0 };
    if (productId) insertData.product_id = productId;
    await (supabase as any).from('roadmap_versions').insert(insertData);
    // Update all other versions to shift their sort_order up by 1
    for (const ver of versions) {
      await (supabase as any).from('roadmap_versions').update({ sort_order: ver.sort_order + 1 }).eq('id', ver.id);
    }
    setNewVersion('');
    fetchData();
    toast.success('Version added!');
  };

  const addItem = async (verId: string) => {
    if (!newItem.trim()) return;
    const ver = versions.find(v => v.id === verId);
    const insertData: any = { 
      version_id: verId, 
      creator_id: creatorId, 
      title: newItem.trim(), 
      description: newItemDesc.trim() || null,
      sort_order: ver?.items?.length || 0 
    };
    if (productId) insertData.product_id = productId;
    await (supabase as any).from('roadmap_items').insert(insertData);
    setNewItem('');
    setNewItemDesc('');
    setAddingTo(null);
    fetchData();
    toast.success('Task added!');
  };

  const updateStatus = async (table: string, id: string, status: string) => {
    await (supabase as any).from(table).update({ status }).eq('id', id);
    fetchData();
  };

  const deleteVersion = async (id: string) => {
    if (!confirm('Delete this version?')) return;
    await (supabase as any).from('roadmap_versions').delete().eq('id', id);
    fetchData();
    toast.success('Deleted');
  };

  const deleteItem = async (id: string) => {
    await (supabase as any).from('roadmap_items').delete().eq('id', id);
    fetchData();
  };

  // Update version description
  const updateVersionDescription = async (versionId: string, description: string) => {
    await (supabase as any).from('roadmap_versions').update({ description: description.trim() || null }).eq('id', versionId);
    setEditingVersionId(null);
    fetchData();
    toast.success('Description updated!');
  };

  // Update task
  const updateTask = async (taskId: string, title: string, description: string) => {
    await (supabase as any).from('roadmap_items').update({ 
      title: title.trim(), 
      description: description.trim() || null 
    }).eq('id', taskId);
    setEditingTaskId(null);
    fetchData();
    toast.success('Task updated!');
  };

  // Fetch replies for a suggestion
  const fetchReplies = async (suggestionId: string) => {
    setLoadingReplies(true);
    try {
      const { data: replies } = await (supabase as any)
        .from('roadmap_suggestion_replies')
        .select('*')
        .eq('suggestion_id', suggestionId)
        .order('created_at', { ascending: true });
      
      if (replies) {
        // Fetch author info for each reply
        const userIds = [...new Set(replies.map((r: any) => r.user_id))];
        const { data: profiles } = await (supabase as any)
          .from('profiles')
          .select('user_id, display_name, avatar_url')
          .in('user_id', userIds);
        
        const profileMap = new Map((profiles || []).map((p: any) => [p.user_id, p]));
        
        const repliesWithAuthors = replies.map((r: any) => ({
          ...r,
          author: profileMap.get(r.user_id) || { display_name: 'Anonymous' },
          is_creator: r.user_id === selectedSuggestion?.creator_id
        }));
        
        setSuggestionReplies(repliesWithAuthors);
      }
    } catch (e) {
      console.error('Error fetching replies:', e);
    }
    setLoadingReplies(false);
  };

  // Submit a reply
  const submitReply = async () => {
    if (!user || !selectedSuggestion || !replyContent.trim()) return;
    setSubmitting(true);
    try {
      await (supabase as any).from('roadmap_suggestion_replies').insert({
        suggestion_id: selectedSuggestion.id,
        user_id: user.id,
        content: replyContent.trim()
      });
      setReplyContent('');
      fetchReplies(selectedSuggestion.id);
      fetchData(); // Refresh to update reply counts
      toast.success('Reply posted!');
    } catch (e) {
      toast.error('Failed to post reply');
    }
    setSubmitting(false);
  };

  // Update suggestion status (creator only)
  const updateSuggestionStatus = async (suggestionId: string, status: string) => {
    await (supabase as any).from('roadmap_suggestions').update({ 
      forum_status: status,
      status_changed_at: new Date().toISOString()
    }).eq('id', suggestionId);
    fetchData();
    if (selectedSuggestion?.id === suggestionId) {
      setSelectedSuggestion(prev => prev ? { ...prev, forum_status: status as any } : null);
    }
    toast.success('Status updated!');
  };

  // Delete suggestion (creator only)
  const deleteSuggestion = async (suggestionId: string) => {
    try {
      // Delete all replies first
      await (supabase as any).from('roadmap_suggestion_replies').delete().eq('suggestion_id', suggestionId);
      // Delete all upvotes
      await (supabase as any).from('roadmap_suggestion_upvotes').delete().eq('suggestion_id', suggestionId);
      // Delete the suggestion
      await (supabase as any).from('roadmap_suggestions').delete().eq('id', suggestionId);
      
      // Close thread if this suggestion was selected
      if (selectedSuggestion?.id === suggestionId) {
        setSelectedSuggestion(null);
        setSuggestionReplies([]);
      }
      
      fetchData();
      toast.success('Suggestion deleted!');
    } catch (e) {
      console.error('Error deleting suggestion:', e);
      toast.error('Failed to delete suggestion');
    }
  };

  // Open suggestion thread
  const openSuggestionThread = (suggestion: RoadmapSuggestion) => {
    setSelectedSuggestion(suggestion);
    fetchReplies(suggestion.id);
  };

  const submitSuggestion = async () => {
    if (!user || !suggestionTitle.trim()) return;
    setSubmitting(true);
    await (supabase as any).from('roadmap_suggestions').insert({ creator_id: creatorId, user_id: user.id, title: suggestionTitle.trim(), description: suggestionDesc.trim() || null });
    setShowModal(false);
    setSuggestionTitle('');
    setSuggestionDesc('');
    setSubmitting(false);
    fetchData();
    toast.success('Suggestion submitted!');
  };

  const toggleUpvote = async (id: string, upvoted: boolean) => {
    if (!user) { toast.error('Sign in to upvote'); return; }
    if (upvoted) {
      await (supabase as any).from('roadmap_suggestion_upvotes').delete().eq('suggestion_id', id).eq('user_id', user.id);
    } else {
      await (supabase as any).from('roadmap_suggestion_upvotes').insert({ suggestion_id: id, user_id: user.id });
    }
    fetchData();
  };

  // Toggle vote on roadmap item
  const toggleItemVote = async (itemId: string, hasVoted: boolean) => {
    if (!user) { toast.error('Sign in to vote'); return; }
    if (!itemVotingEnabled) { toast.error('Voting is not enabled for this roadmap'); return; }
    
    try {
      if (hasVoted) {
        await (supabase as any).from('roadmap_item_votes').delete().eq('item_id', itemId).eq('user_id', user.id);
      } else {
        await (supabase as any).from('roadmap_item_votes').insert({ item_id: itemId, user_id: user.id });
      }
      fetchData();
    } catch (e) {
      console.error('Error toggling vote:', e);
      toast.error('Failed to update vote');
    }
  };

  // Toggle voting settings (owner only)
  const toggleVotingSettings = async (field: 'voting_enabled' | 'sort_by_votes', value: boolean) => {
    if (!productId || !isOwner) return;
    
    try {
      await (supabase as any).from('products').update({ [field]: value }).eq('id', productId);
      if (field === 'voting_enabled') setItemVotingEnabled(value);
      if (field === 'sort_by_votes') setItemSortByVotes(value);
      fetchData();
      toast.success(field === 'voting_enabled' 
        ? (value ? 'Voting enabled!' : 'Voting disabled!') 
        : (value ? 'Sorting by votes!' : 'Sorting by order!')
      );
    } catch (e) {
      toast.error('Failed to update settings');
    }
  };

  // Toggle per-item voting (owner only)
  const toggleItemVotingEnabled = async (itemId: string, currentValue: boolean) => {
    if (!isOwner) return;
    
    try {
      await (supabase as any).from('roadmap_items').update({ voting_enabled: !currentValue }).eq('id', itemId);
      fetchData();
      toast.success(!currentValue ? 'Voting enabled for this task!' : 'Voting disabled for this task!');
    } catch (e) {
      toast.error('Failed to update voting setting');
    }
  };

  // Build background style - glass effect works on any background
  let bgStyle: React.CSSProperties = {};
  
  // Check if roadmap has its own background settings
  const hasOwnBackground = settings.backgroundType && settings.backgroundType !== 'default';
  
  if (hasOwnBackground) {
    // Use roadmap-specific background
    if (settings.backgroundType === 'image' && settings.backgroundImage) {
      const overlayOpacity = (settings.backgroundOverlayOpacity || 70) / 100;
      bgStyle = {
        backgroundImage: 'linear-gradient(rgba(0, 0, 0, ' + overlayOpacity + '), rgba(0, 0, 0, ' + overlayOpacity + ')), url(' + settings.backgroundImage + ')',
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        backgroundAttachment: 'fixed'
      };
    } else if (settings.backgroundType === 'gradient') {
      const start = settings.useCustomColors ? settings.customBackgroundGradientStart : (theme.backgroundGradient?.start || theme.backgroundColor);
      const end = settings.useCustomColors ? settings.customBackgroundGradientEnd : (theme.backgroundGradient?.end || theme.backgroundColor);
      bgStyle = { background: 'linear-gradient(135deg, ' + start + ' 0%, ' + end + ' 100%)' };
    } else if (settings.backgroundType === 'solid') {
      bgStyle = { backgroundColor: settings.customBackgroundColor || theme.backgroundColor };
    }
  } else if (globalBackground?.enabled) {
    // Use global background as fallback
    if (globalBackground.type === 'image' && globalBackground.image) {
      const overlayOpacity = globalBackground.overlay || 0.5;
      bgStyle = {
        backgroundImage: 'linear-gradient(rgba(0, 0, 0, ' + overlayOpacity + '), rgba(0, 0, 0, ' + overlayOpacity + ')), url(' + globalBackground.image + ')',
        backgroundSize: 'cover',
        backgroundPosition: 'center',
        backgroundAttachment: 'fixed'
      };
    } else if (globalBackground.type === 'gradient') {
      const start = globalBackground.gradientStart || '#0f172a';
      const end = globalBackground.gradientEnd || '#1e1b4b';
      bgStyle = { background: 'linear-gradient(135deg, ' + start + ' 0%, ' + end + ' 100%)' };
    } else if (globalBackground.type === 'solid') {
      bgStyle = { backgroundColor: globalBackground.color || '#0f172a' };
    }
  } else if (settings.useBackgroundGradient || theme.backgroundGradient) {
    // Legacy: use theme gradient
    const start = settings.useCustomColors ? settings.customBackgroundGradientStart : (theme.backgroundGradient?.start || theme.backgroundColor);
    const end = settings.useCustomColors ? settings.customBackgroundGradientEnd : (theme.backgroundGradient?.end || theme.backgroundColor);
    bgStyle = { background: 'linear-gradient(135deg, ' + start + ' 0%, ' + end + ' 100%)' };
  } else {
    bgStyle = { backgroundColor: settings.useCustomColors ? settings.customBackgroundColor : theme.backgroundColor };
  }



  // Get status-based colors (Premium style)
  const getStatusColors = (status: string) => {
    return STATUS_COLORS[status] || STATUS_COLORS.backlog;
  };

  if (loading) return (
    <div className="min-h-screen flex items-center justify-center" style={bgStyle}>
      <Loader2 className="w-12 h-12 animate-spin" style={{ color: theme.accentColor }} />
    </div>
  );

  return (
    <div className="min-h-screen relative" style={{ ...bgStyle, fontFamily: settings.fontFamily || 'Inter, sans-serif' }}>
      {/* Animated Background Orbs - Customizable */}
      {settings.showFloatingOrbs !== false && (
        <div className="fixed inset-0 overflow-hidden pointer-events-none">
          {Array.from({ length: settings.orbCount || 3 }, (_, index) => {
            const positions = [
              { top: '10%', left: '10%' },
              { bottom: '10%', right: '10%' },
              { top: '50%', right: '20%' },
              { bottom: '30%', left: '15%' },
              { top: '20%', right: '40%' },
              { bottom: '60%', left: '60%' }
            ];
            const sizes = [384, 320, 256, 300, 280, 240];
            
            return (
              <FloatingOrb 
                key={index}
                color={settings.orbColor || theme.accentColor} 
                size={sizes[index] || 256} 
                position={positions[index] || { top: '50%', left: '50%' }} 
                delay={index * 2} 
              />
            );
          })}
        </div>
      )}

      {/* Header with Logo */}
      {settings.showHeader !== false && (
        <div 
          className="border-b backdrop-blur-xl relative z-10" 
          style={{ 
            borderColor: 'rgba(255, 255, 255, 0.1)', 
            backgroundColor: 'rgba(15, 23, 42, 0.8)'
          }}
        >
          <div className={`${settings.roadmapWidth || 'max-w-7xl'} mx-auto px-8 py-4 flex items-center justify-between`}>
            <div className="flex items-center gap-4">
              {/* Back button when viewing specific product roadmap */}
              {onBack && (
                <button
                  onClick={onBack}
                  className="flex items-center gap-2 px-3 py-2 rounded-lg transition-all hover:bg-white/10"
                  style={{ color: theme.textSecondary }}
                >
                  <ArrowLeft className="w-5 h-5" />
                  <span className="text-sm font-medium">All Roadmaps</span>
                </button>
              )}
              {settings.showLogo !== false && storeLogo && (
                <img src={storeLogo} alt="Logo" className="h-10 object-contain" />
              )}
              {(!storeLogo || settings.showLogo === false) && storeName && (
                <span className="text-xl font-bold" style={{ color: theme.textPrimary }}>{storeName}</span>
              )}
            </div>
            <div className="flex items-center gap-3">
              {/* Community Forums Link */}
              {storeSlug && (
                <Button 
                  onClick={() => navigate(`/site/${storeSlug}/community`)} 
                  variant="outline"
                  className="px-5 py-2 font-semibold rounded-full transition-all hover:scale-105"
                  style={{ 
                    backgroundColor: 'rgba(255,255,255,0.1)',
                    color: theme.textPrimary,
                    borderColor: 'rgba(255,255,255,0.2)',
                  }}
                >
                  <Users className="w-4 h-4 mr-2" />
                  Community
                </Button>
              )}
              <Button 
                onClick={() => setShowModal(true)} 
                className="px-5 py-2 font-semibold rounded-full transition-all hover:scale-105 hover:shadow-lg"
                style={{ 
                  background: `linear-gradient(135deg, ${theme.accentColor}, ${theme.accentColor}dd)`,
                  color: '#ffffff',
                  boxShadow: `0 0 ${20 * ((settings.glowIntensity || 50) / 100)}px ${theme.accentColor}40, 0 0 ${30 * ((settings.glowIntensity || 50) / 100)}px ${theme.accentColor}20`,
                  border: 'none'
                }}
              >
                <Lightbulb className="w-4 h-4 mr-2" />
                Suggest Feature
              </Button>
            </div>
          </div>
        </div>
      )}

      <div className={`${settings.roadmapWidth || 'max-w-7xl'} mx-auto px-8 py-10 relative z-10`}>
        {/* Title Section - Premium Style */}
        <div className="text-center mb-16">
          <h1 
            className={`${settings.mainTitleSize || 'text-6xl md:text-7xl'} font-black mb-6 bg-clip-text text-transparent`}
            style={{ 
              backgroundImage: `linear-gradient(135deg, ${theme.accentColor}, ${theme.accentColor}aa)`,
            }}
          >
            {productName || settings.title}
          </h1>
          <p className="text-xl" style={{ color: theme.textSecondary }}>{productName ? 'Product Roadmap' : settings.subtitle}</p>
        </div>

        {/* Owner: Add Version & Voting Settings */}
        {isOwner && (
          <div 
            className="mb-6 p-4 rounded-xl border backdrop-blur-lg" 
            style={{ 
              backgroundColor: 'rgba(30, 41, 59, 0.5)', 
              borderColor: theme.cardBorder 
            }}
          >
            <div className="flex gap-3 mb-4">
              <Input 
                placeholder="New version (e.g. v1.4.0 - Update)" 
                value={newVersion} 
                onChange={e => setNewVersion(e.target.value)} 
                onKeyDown={e => e.key === 'Enter' && addVersion()} 
                className="flex-1"
                style={{ backgroundColor: 'rgba(0,0,0,0.4)', borderColor: theme.cardBorder, color: theme.textPrimary }} 
              />
              <Button 
                onClick={addVersion} 
                className="transition-all hover:scale-105"
                style={{ backgroundColor: theme.accentColor, color: '#fff', boxShadow: `0 0 ${20 * ((settings.glowIntensity || 50) / 100)}px ${theme.accentColor}40` }}
              >
                <Plus className="w-4 h-4 mr-2" />Add Version
              </Button>
            </div>
            
            {/* Voting Settings */}
            {productId && (
              <div className="flex items-center gap-6 pt-3 border-t" style={{ borderColor: 'rgba(255,255,255,0.1)' }}>
                <div className="flex items-center gap-2">
                  <Vote className="w-4 h-4" style={{ color: theme.textSecondary }} />
                  <span className="text-sm" style={{ color: theme.textSecondary }}>Voting:</span>
                  <button
                    onClick={() => toggleVotingSettings('voting_enabled', !itemVotingEnabled)}
                    className={`px-3 py-1 rounded-full text-xs font-semibold transition-all ${itemVotingEnabled ? 'bg-green-500/20 text-green-400 border border-green-500/50' : 'bg-gray-500/20 text-gray-400 border border-gray-500/50'}`}
                  >
                    {itemVotingEnabled ? 'Enabled' : 'Disabled'}
                  </button>
                </div>
                {itemVotingEnabled && (
                  <div className="flex items-center gap-2">
                    <span className="text-sm" style={{ color: theme.textSecondary }}>Sort by votes:</span>
                    <button
                      onClick={() => toggleVotingSettings('sort_by_votes', !itemSortByVotes)}
                      className={`px-3 py-1 rounded-full text-xs font-semibold transition-all border`}
                      style={{
                        backgroundColor: itemSortByVotes ? `${theme.accentColor}33` : 'rgba(107, 114, 128, 0.2)',
                        color: itemSortByVotes ? theme.accentColor : '#9ca3af',
                        borderColor: itemSortByVotes ? `${theme.accentColor}80` : 'rgba(107, 114, 128, 0.5)'
                      }}
                    >
                      {itemSortByVotes ? 'On' : 'Off'}
                    </button>
                  </div>
                )}
              </div>
            )}
          </div>
        )}
